---
title: "Network similarity & scales effect"
description: 
output: html_notebook
author: Ize Buphamalai
date: 18 May 2020
---

One disease > more functions > 

```{r process LCC results}
# download the results

rare_genetic_result_folder = "../cache/output/Orphageneset_rare/"

# load  network labels
network_info = read_tsv("../data/network_details.tsv")

source("../functions/process_LCC_result.R")

## process the results LCC significance
result_df = readRDS(paste0(rare_genetic_result_folder, "LCC_and_distance_calculation_results.RDS"))
  
processed_result_df = process_LCC_result(result_df)


## extract the list of significant diseases for each disease
signif_disease <- processed_result_df %>% mutate(name = as.character(name)) %>% dplyr::filter(LCC.signif != "none") %>% group_by(network) %>% summarise(all_disease_signif = list(name)) %>% deframe()
```


# The network similarity level
If the human phenotypic similartiy network is a benchmark for other layers. The ways to approach this include:

 - Jaccard index similarity 
 - Overlap index (the denominator is min(|A|),|B|) instad of |A U B|, better indicate the subset nature
 - Degree correlation -> node/periphery structure
 
```{r}

# compute the degree correlation
degree_cor <- function(name1, name2){
  deg_g1 <- degree(g[[name1]])
  deg_g2 <- degree(g[[name2]])
  commonindex <- intersect(names(deg_g1), names(deg_g2))
  
  spearman_cor <- cor(deg_g1[commonindex], deg_g2[commonindex], method = "spearman")
  return(spearman_cor)
}

network_sim_df$degree_cor <-  apply(network_sim_df, 1, function(x) degree_cor(x[1], x[2])) 

# jaccard index and absolute number of common significant networks
signif_disease_compute <- function(name1, name2){
  Union12 <- length(union(signif_disease[[name1]], signif_disease[[name2]]))
  Intersect12 <- length(intersect(signif_disease[[name1]], signif_disease[[name2]]))
  J12 <- Intersect12/Union12
  
  return(c(jaccardIndex_disease = J12, N_commondisease = Intersect12))
}


commonDiseaseLCC <-  apply(network_sim_df, 1, function(x) signif_disease_compute(x[1], x[2]))  %>% t %>% as_tibble()
network_sim_df <- bind_cols(network_sim_df, commonDiseaseLCC)

colnames(network_sim_df)[1:2] <- c("network1", "network2")
```
 
 
## Tissue similarity, by the overlap index
```{r}
library(RColorBrewer)

coex_sim <- network_sim_df %>% dplyr::filter(grepl("coex", network1) & grepl("coex", network2)) %>% mutate(network1 = str_remove(network1, "coex_"),network2 = str_remove(network2, "coex_"))

#completed
coex_sim_sym <- rbind(coex_sim, cbind(tibble(network1 = coex_sim$network2, network2 = coex_sim$network1), coex_sim[,-c(1:2)]))

coex_sim_jaccard_mat <- dcast(coex_sim_sym, network1 ~ network2, value.var = "overlapindex") %>% column_to_rownames(var = "network1") %>% as.matrix

heatmap(coex_sim_jaccard_mat, #cexRow=1.5, 
        col= colorRampPalette(brewer.pal(8, "Blues"))(25))
```

```{r}
reorder_cormat <- function(cormat){
# Use correlation between variables as distance
dd <- as.dist((1-cormat)/2)
hc <- hclust(dd)
cormat <-cormat[hc$order, hc$order]
}


get_upper_tri <- function(cormat){
  cormat[lower.tri(cormat)]<- NA
  return(cormat)
}

get_lower_tri <- function(cormat){
  cormat[upper.tri(cormat)]<- NA
  return(cormat)
}

coex_reduced_mat <- reorder_cormat(coex_sim_jaccard_mat)
upper_tri <- get_upper_tri(coex_reduced_mat)
# Melt the correlation matrix
coex_reduced_df <- melt(upper_tri, na.rm = TRUE)
# Create a ggheatmap

ggplot(coex_reduced_df, aes(Var1, Var2, fill = value))+
 geom_tile(color = "white")+
  ylab("Tissue") + ylab("") +
# scale_fill_gradient2(low = "blue", high = "red", mid = "white", 
#   midpoint = 0, limit = c(-1,1), space = "Lab", 
#    name="Pearson\nCorrelation") +
  scale_fill_gradient(low = "white", high = "#005564") +
  theme_minimal()+ # minimal theme
 theme(axis.text.x = element_text(angle = 90))+
 coord_fixed()
```

## Overlap Index of the Tissue similarity before edge reduction

```{r}
# raw counts
coex_folder = "../networks/gtex_coexpresssion/edgelists/coex_dispfilter_001_cor075/"

g_coex_raw = list()

all_tissue_files <-  list.files(coex_folder)

for(i in all_tissue_files){
  tissue_name = str_remove(i, ".tsv")
  
  g_coex_raw[[tissue_name]] = read_tsv(paste0(coex_folder, i), col_types = "cc") %>% graph_from_data_frame(., directed = F)
}

# compute jaccard and overlap similarity
network_coex_raw_sim_df = combn(names(g_coex_raw),m = 2, simplify = T) %>% t() %>% as_tibble

# this process may take really long
simIndex_coex_raw = apply(network_coex_raw_sim_df, 1, function(x) graph_similarity(g_coex_raw, x[1], x[2])) 

simIndex_coex_raw_df <- as_tibble(t(simIndex_coex_raw))

# merge the results
network_coex_raw_sim_df <- bind_cols(network_coex_raw_sim_df, simIndex_coex_raw_df)
colnames(network_coex_raw_sim_df)[1:2] <- c("network1","network2")

#completed
coex_raw_sim_sym <- rbind(network_coex_raw_sim_df, cbind(tibble(network1 = network_coex_raw_sim_df$network2, network2 = network_coex_raw_sim_df$network1), network_coex_raw_sim_df[,-c(1:2)]))

coex_raw_sim_jaccard_mat <- dcast(coex_raw_sim_sym, network1 ~ network2, value.var = "overlapindex") %>% column_to_rownames(var = "network1") %>% as.matrix

# reorder the column based on the upper triangle previously computed
coex_raw_mat <- coex_raw_sim_jaccard_mat[rownames(coex_reduced_mat), rownames(coex_reduced_mat)]
lower_tri <- get_lower_tri(coex_raw_mat)
# Melt the correlation matrix
coex_raw_df <- melt(lower_tri, na.rm = TRUE)

coex_reduced_df$type <- "reduced"
coex_raw_df$type <- "full"

coex_raw_reduced_merged_df <- bind_rows(coex_reduced_df, coex_raw_df)

p <- ggplot(coex_raw_reduced_merged_df, aes(Var1, Var2, fill = value))+
 geom_tile(color = "white")+
  ylab("Tissue") + ylab("") + xlab("")+
# scale_fill_gradient2(low = "blue", high = "red", mid = "white", 
#   midpoint = 0, limit = c(-1,1), space = "Lab", 
#    name="Pearson\nCorrelation") +
  scale_fill_gradient(low = "white", high = "#005564") +
  theme_minimal()+ # minimal theme
 theme(axis.text.x = element_text(angle = 90, vjust = 0))+
 coord_fixed() + theme(legend.position = "bottom")

ggsave("../Figs/heatmap_coex_similarity_reduced_vs_full_edges.pdf", height = 6, width = 6)

```



# The Jaccard and overlap index for other layers

```{r}
library(ggrepel)
dat <- network_sim_df %>% dplyr::filter(network1 == "HP" | network2 == "HP") %>% mutate(label = paste0(network1, network2) %>% str_remove(., "HP"), coex = grepl("coex", label))

ggplot(dat, aes(x = N_commondisease, y = overlapindex, col = coex)) + geom_point() + scale_y_log10() + geom_label_repel(aes(label = ifelse(!coex,label,""))) 
```

Changing the x-axis to absolute number of signif disease
```{r}
dat$N_signif_disease <- sapply(dat$label, function(x) length(signif_disease[[x]]))

dat$node_size <- sapply(dat$label, function(x) vcount(g[[x]]))
dat$edge_size <- sapply(dat$label, function(x) ecount(g[[x]]))
dat <- dat %>% mutate(graph_density = edge_size/(node_size*(node_size-1)/2))

ggplot(dat, aes(x = N_signif_disease, y = overlapindex)) + geom_point(aes(col = coex, size = graph_density, alpha = 0.5)) + scale_y_log10() + geom_text_repel(aes(label = ifelse(!(coex & N_signif_disease < 10) ,label,""))) + theme_classic()
```

```{r}
network_full_name <- network_info %>% select(network, subtype) %>% deframe

p <- ggplot(dat %>% mutate(label=network_full_name[label]), aes(x = N_signif_disease, y = overlapindex)) + 
  geom_point(aes(col = coex, size = graph_density), alpha = 0.5, fill=NA) + 
  scale_y_log10() + 
  geom_text_repel(aes(label = ifelse(!coex ,label,""))) + 
  theme_classic() +
  xlab("Number of significant diseases") + ylab("HP Overlap Index")+
  guides(col=F, alpha =F, size = F) +
  scale_color_manual(values = c("#005564","#F8B100"))

ggsave("../Figs/scatterplot_N_signif_networks_vs_HP_overlap.pdf",p,  width = 3.5, height = 3.5)
```


# several features compared to HP
```{r}
dat_long <- gather(dat, measurement, value, jaccardIndex:N_commondisease, factor_key=TRUE)

ggplot(dat_long %>% dplyr::filter(!coex)) + geom_col(aes(x = value, y = label)) + facet_grid(.~measurement, scale = "free")
```


```{r}
selected_networks = c("coessential", "ppi", "GOBP",
"reactome_copathway_shared_over_5",  "HP")
selected_networks_names = c("Genetic", "Protein", "Function", "Pathway", "Phenotype")

result_df_inspect = result_df_inspect %>% 
  dplyr::filter(network %in% selected_networks) %>%
  mutate(network = factor(network, levels = selected_networks, labels = selected_networks_names))


ggplot(result_df_inspect) + geom_boxplot(aes(x = network, y = LCC.zscore))
```


```{r}
ggplot(result_df_inspect) + geom_boxplot(aes(x = network, y = -log10(unlist(d_s_signif.zpval))))

ggplot(result_df_inspect) + geom_boxplot(aes(x = network, y = unlist(d_s_signif.zscore)))
```


